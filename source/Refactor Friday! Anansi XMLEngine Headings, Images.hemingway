{"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://github.com/christian-westbrook/anansi"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://hemingwayapp.com/"}},"2":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://en.wikipedia.org/wiki/Regular_expression"}},"3":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://github.com/christian-westbrook/anansi/pull/45/files"}},"4":{"type":"LINK","mutability":"MUTABLE","data":{"href":"mailto:christianwestbrook@live.com"}}},"blocks":[{"key":"e7rjc","text":"Refactor Friday! Anansi XMLEngine Headings, Images","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fgerk","text":"Welcome to the first Refactor Friday! In this blog series I'll take on one small refactoring task at a time and explain:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e6mjk","text":"Why I chose to refactor","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"987ce","text":"How I plan to fix it","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bssvm","text":"Today I'm refactoring Anansi, the open-source blogging and portfolio engine!","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":22,"length":6,"key":0}],"data":{}},{"key":"cc6c0","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"687pv","text":"Situation","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3n4qa","text":"Anansi is a minimalist blogging platform that's mostly written in PHP. In fact, this site is a deployment of Anansi! It's purpose is simple: to give authors a simple, open-source solution for blog hosting.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8t31b","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d4ntt","text":"To provide the actual blog feed, Anansi reads from a store of XML files representing blog posts. Each blog's file stores content written in Markdown, which is easy to deal with when writing. I love that my favorite writing tool supports exporting text as Markdown content!","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":203,"length":24,"key":1}],"data":{}},{"key":"6q335","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6errf","text":"Web browsers don't understand Markdown, though. Before we can render a blog post in all its glory, we need to convert it to a format the browser can understand. We need a way to parse Markdown content and generate equivalent HTML content. Cue the XMLEngine class!","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3f4eo","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"69m5f","text":"XMLEngine is a PHP class that provides services related to Anansi's blog files. Its implementation, however, deals with XML, Markdown, and HTML! It appears to represent the blogs themselves rather than an XML processing tool. This is clearly an overloaded class with room for improvement, but I'll save that for another blog!","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7l9ui","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6inu0","text":"Problem Statement","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5jrud","text":"XMLEngine provides a method that performs Markdown to HTML conversion. This method uses regular expressions to decide what exactly a given line represents. Is it a heading? An image?","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":88,"length":19,"key":2}],"data":{}},{"key":"aopgs","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fn2hb","text":"Once the method knows the kind of line it's looking at, it can follow a series of rules for converting that line to HTML. These rules cover several different kinds of lines. Because of this, the method is getting long and becoming difficult to read.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"53coc","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"37le1","text":"It's hard to overstate how important it is for code to be readable. Humans read source code fare more often than they write it. You will read your code several times for every chance you have to refactor it. One of the easiest ways to up your game as an engineer is to write readable code.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fqbmp","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a7j68","text":"Design","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4k8hu","text":"Anansi currently supports the following Markdown content:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fgb9m","text":"Headings","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5jnfh","text":"Images","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2nqov","text":"Hyperlinks","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6vvhl","text":"Bold and italic text","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ft21","text":"Unordered lists","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cd7d7","text":"Newlines","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fasrd","text":"Plain text","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d0pkc","text":"A simple improvement here would be to grab groups of related statements and combine them. I'll create a series of new methods for handling each of these kinds of content. In today's refactor I'll tackle the first two cases: headings and images.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a2efv","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dgoud","text":"Implementation","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fm91u","text":"I started by creating a new method for converting Markdown headings to HTML. I replaced the original block of code with a single regular expression check and method call. This task made some potential improvements immediately visible.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fdeqp","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"52esd","text":"SHOW BEFORE AND AFTER","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1v2tj","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6es1","text":"In Markdown we use number signs (#) to represent headings. Their count is important: more number signs should result in a smaller heading. In the original logic I used several regular expression checks to identify headings. Each check mapped to a heading of a certain size.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"119ln","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6jpmq","text":"SHOW REGEX CHECKS BEFORE","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"373du","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9jdlf","text":"Reviewing this code made me realize that it would be a lot simpler to just count number signs! Given the initial check, I can assume that I'm working with a heading once inside the new method. I was able to compress all this logic into four lines by depending on that assumption. The new method counts the number signs used to define the heading and creates a new heading in HTML of the same size.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9fj01","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8hpl0","text":"SHOW NEW SMALLER LOGIC","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9l6u5","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7sha0","text":"Next I created a second method for handling images. I replaced the original block of code with a similar check and call to the new method.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3ftnd","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6i9e5","text":"SHOW BEFORE AND AFTER","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5d0vd","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1fibe","text":"The new conversion logic is a lot like the original. I'm not entirely sure why, but the original handles a case where the image is embedded in the middle of a line. The main improvement here is a new assumption that images will exist on their own lines.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9qetr","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ja95","text":"SHOW NEW METHOD","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"79oen","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"86cbs","text":"The Verdict","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8vbkj","text":"I really like how these two new methods turned out! You can see the diffs yourself here. I felt uneasy about XMLEngine's design, but this tiny refactor sparked new ideas I'm excited to try!","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":83,"length":4,"key":3}],"data":{}},{"key":"76q7k","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d6dra","text":"Just within this method other kinds of supported Markdown content needs isolated. Some of them will be trickier to handle. For instance, unordered lists stretch across many lines. That should make for a more interesting refactor.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3dn71","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5jlov","text":"The XMLEngine class itself should be a candidate for a future refactor. Its abstraction could represent a single blog post and supporting operations. I could even split it into multiple classes if it would be useful to isolate common support methods.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b1pg","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4kcfo","text":"Looking back at your code is an opportunity to learn. Are your solutions easy to understand when they're revisited? Can you derive why you made key design decisions? Are there any that you would change today? Take advantage of seeing your work from the maintainer's point of view, and then make it easy to maintain.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a4tj9","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dg971","text":"Thanks for joining me on my first Refactor Friday! I'm looking forward to using this format again to share examples of how I think about refactoring.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":21,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"717el","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"flckf","text":"How did I do? Would you have done something differently? I'd love to hear your thoughts! As always, feel free to reach out to me at christianwestbrook@live.com","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":132,"length":27,"key":4}],"data":{}},{"key":"b9cbn","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f2num","text":"Signing off,","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ikl0","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e5890","text":"Christian","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"epbd1","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"43oi3","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"h594","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bo2ue","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]}